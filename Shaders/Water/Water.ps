#include "ObjectBuffer.hlsl"
#include "EnvBuffer.hlsl"
#include "SceneTexture.hlsl"
#include "PixelShader.hlsl"

Texture2D RippleMap;
Texture2D WaveMap;
SamplerState TextureSampler;

#define WATER_RIPPLE_DIR DirParams.xy
#define WATER_RIPPLE_SPEED RippleParams.x
#define WATER_RIPPLE_TILING RippleParams.y
#define WATER_RIPPLE_WARP_SCALE RippleParams.z
 
#define WATER_WAVE_DIR DirParams.zw
#define WATER_WAVE_SPEED WaveParams.x
#define WATER_WAVE_TILING (WaveParams.y * 1)
#define WATER_WAVE_NORM_EQUALIZER (WaveParams.z / 1)
#define WATER_WAVE_ATTEN (WaveParams.w)

cbuffer MaterialBuffer
{
	float4 DirParams;
	float4 RippleParams;
	float4 WaveParams;
	float4 WaterColor0;
	float4 WaterColor1;
	float4 WaveColor;
	float4 SpecularColor;
};

struct PS_In
{
	float4 clipPos : SV_POSITION;
	float4 projCoord : PROJCOORD;
	float4 normal : NORMAL;
	float4 position : POSITION;
	float2 texCoord : TEXCOORD;
};

PixelOutput ps(PS_In pIn)
{
	PixelOutput pOutput;

	float2 texCoord = pIn.position.xz;

	float2 rippleOffset = WATER_RIPPLE_DIR * ELAPSED_TIME * WATER_RIPPLE_SPEED;	
	float2 ripple = 
		WaveMap.Sample(TextureSampler, texCoord * WATER_RIPPLE_TILING + rippleOffset * 2.0).xy + 
		WaveMap.Sample(TextureSampler, -texCoord * WATER_RIPPLE_TILING * 2.0 + rippleOffset).xy;
	ripple *= 0.5;
	ripple = (ripple * 2.0 - 1.0) * WATER_RIPPLE_WARP_SCALE;
	
	float2 waveOffset = WATER_WAVE_DIR * ELAPSED_TIME * WATER_WAVE_SPEED;
	float3 wave0 = WaveMap.Sample(TextureSampler, ripple + texCoord * WATER_WAVE_TILING + waveOffset).rgb;
	float3 wave1 = WaveMap.Sample(TextureSampler, ripple + -texCoord.yx * WATER_WAVE_TILING * 1.25 + waveOffset * 0.75).rgb;
	float3 waveNormal = normalize(((wave0 + wave1) * 0.5).rbg * 2.0 - 1.0);	
	
	pOutput.normal = normalize(mul(normalize(float4((waveNormal * 0.5 + 0.5) * float3(1, WATER_WAVE_NORM_EQUALIZER, 1), 0.0)), NormalMatrix));
		
	float3 V = normalize((InvViewMatrix[3] - pIn.position).xyz);
	float3 N = normalize(mul(float4(waveNormal, 0.0), NormalMatrix)).xyz;
	float cosFresnel = max(dot(V, N), 0.0);
	float fresnel = RippleMap.Sample(TextureSampler, float2(cosFresnel, 0.0)).r;

	//fresnel = pow(1.0- cosFresnel, 2.0);
	
	float2 projCoord = pIn.projCoord.xy / pIn.projCoord.w;
	projCoord = projCoord * 0.5 + 0.5;
	float2 screenPos = projCoord;
	projCoord.y = 1.0 - projCoord.y;
	projCoord += waveNormal.xz * 0.1;
	
	//float fr = max(dot(V, normalize(pIn.normal.xyz)), 0.0);
	//fr = max(dot(V, N2), 0.0);
	//
	//float4 sampledPos = float4(screenPos, SampleDepth(projCoord), 1.0);
	//sampledPos.xy = sampledPos.xy * 2.0 - 1.0;
	//sampledPos = mul(sampledPos, InvProjMatrix);
	//sampledPos /= sampledPos.w;
	//sampledPos = mul(sampledPos, InvViewMatrix);
	//
	///*
	//float4 thisPos = float4(screenPos, pIn.clipPos.z, 1.0);
	//thisPos.xy = thisPos.xy * 2.0 - 1.0;
	//thisPos = mul(thisPos, InvProjMatrix);
	//thisPos /= thisPos.w;
	//thisPos = mul(thisPos, InvViewMatrix);
	//*/	
	//
	////if the sampled position is above the water,
	////reverse the refraction offset. Should fix "most" issues with getting
	////a foreground object incorrectly being refracted in the water
	//if(sampledPos.y > pIn.position.y) 
	//{
	//	projCoord -= waveNormal.xz * 0.1;
	//}
	
	float4 scene = SampleScene(projCoord);

	pOutput.albedo.rgb = lerp(WaterColor0.rgb, WaterColor1.rgb, fresnel * WATER_WAVE_ATTEN);
	//pOutput.albedo.rgb = lerp(pOutput.albedo.rgb, scene.rgb, fr * 0);
	pOutput.worldPosition = pIn.position;
	pOutput.specular = float4(1,1,1, 512);

	return pOutput;
}